# Exam. Garbage Collector

## Оглавление

1. [Чем Java отличается от C++? ](#1-Чем-Java-отличается-от-C)
2. [Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)
3. [Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)
4. [Опишите процесс работы сборщика мусора.](#4-Опишите-процесс-работы-сборщика-мусора)
5. [Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)
6. [Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)
7. [Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)
8. [Что такое ссылки?](#8-Что-такое-ссылки)
9. [Какие типы ссылок Вы знаете?](#9-Какие-типы-ссылок-Вы-знаете)
10. [Чем они отличаются?](#10-Чем-они-отличаются)
11. [Расскажите про String pool и Int pool.](#11-Расскажите-про-String-pool-и-Int-pool)
12. [Расскажите о методе String.intern().](#12-Расскажите-о-методе-String-intern)
13. [Расскажите, что такое профайлер.](#13-Расскажите-что-такое-профайлер)
14. [Расскажите, как использовать VisualVM.](#14-Расскажите-как-использовать-VisualVM)
15. [Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)](#15-Расскажите-чем-отличается-sampling-от-profiling-Это-типы-аудита-Режим-работы-в-профайлере)
16. [Расскажите о методе finalize().](#16-Расскажите-о-методе-finalize)
17. [Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#17-Расскажите-о-методе-clone-Что-такое-Deep-clone-and-Shallow-clone)
18. [Расскажите о Stack и Heap.](#18-Расскажите-о-Stack-и-Heap)

## 1 Чем Java отличается от C++?

+ Управлением памятью: в Java автоматическая сборка мусора, в то время как в С++ программисту нужно самому позаботиться
  о выделении и освобождении памяти.

К оглавлению [&#8593;](#Оглавление)

## 2 Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на
выделение и освобождение оперативной памяти.

К оглавлению [&#8593;](#Оглавление)

## 3 Какой механизм используется в Java для управления памятью?

В Java используется автоматическое управление памятью, называемое сборкой мусора. Все создаваемые программой объекты
находятся в области памяти под названием "куча" (heap). 2*) JVM использует больше памяти, чем занимает куча. Для методов
Java и стеков потоков выделяется память отдельно от кучи. Когда объекты занимают в куче много места, происходит очистка
ее от уже не используемых, "мертвых" объектов - сборка мусора. Сборщик мусора - это отдельный поток, который действует
автоматически и в общем случае не требует внимания программиста, позволяя тому сосредоточиться на бизнес-логике.

Распределение памяти в java реализует технология Java HotSpot от Oracle. Она обеспечивает динамическое выделение памяти
для объектов и сборщиков мусора.

Память процесса делится на _non-heap_ (до JDK 8 stack) и _heap_ (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation. Начиная с JDK 8, permanent
generation было удалено, а метаданные класса размещены в собственной памяти. Объем собственной памяти, которую можно
использовать для метаданных класса, по умолчанию не ограничен. Permanent Generation — содержит необходимые для
управления программой метаданные классов, в том числе метаданные о созданных объектах, методах и т.п.

Code Cache — используемая JVM память при включенной JIT-компиляции (в этой области памяти кешируется скомпилированный
платформенно-зависимый код)

Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и
старое (old). Young generation состоит из eden и survivor space.

Heap - куча (тут и работает GC)

New (Young) Generation - хранит короткоживущие объекты.

Eden Space — сюда аллоцируются среднестатистические объекты. Если нет места запускается малая сборка мусора (minor GC).

Survivor Space — точнее их два, S1 и S2, и они меняются ролями. Хранятся перемещенные из Eden Space объекты, признанные
живыми во время сборки мусора (без разницы малой или полной). Объекты, пережившие несколько сборок мусора, перемещаются
в следующую сборку Tenured Generation.

Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, выполняется полная
сборка мусора (full GC).

Выбор «поколенческой» (generational) модели памяти сделан не спроста. Опытным путем было доказано, что большинство
объектов не живут долго. Это заключение, позволяет сделать young generation небольшим, а в old generation хранить
объекты действительно «живущие» дольше обычного, тем самым эффективно использовать память.

К оглавлению [&#8593;](#Оглавление)

## 4 Опишите процесс работы сборщика мусора.

Сборка мусора происходит, когда заполнена вся область памяти. Раз память делится на два поколения, то бывает два типа
сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда
переполняется область из old generation.

1. Все объекты рождаются в eden (young generation). Объект рождается. Во время исполнения JVM видит, что стоит оператор
   new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти.
2. GC помечает "живые" объекты (то есть объекты, на которые есть ссылки)
3. Происходит удаление "неживых" объектов
4. Объекты, пережившие сборку мусора, переходят в область survivor (s1)
5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age).
   Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется
   «взрослением» (aging).
6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением»
   promotion.
7. Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для
   очищения young generation.
8. Когда old generation заполняется производится major GC
9. Этапы 1-7 происходят на протяжении работы программы

К оглавлению [&#8593;](#Оглавление)

## 5 Какие алгоритмы сборщика вы знаете?

По исполнению сборки выделяют:

+ Последовательное (Serial) - сборка выполняется только в одном потоке и задействует только один процессор, что
  увеличивает время сборки.
+ Параллельное (Parallel) - сборка выполняется в разных потоках за счёт использования нескольких процессоров, что
  уменьшает время сборки, ценой затрат ресурсов (процессоров) и некоторых накладных расходов (overhead), требуемых для
  организации работы потоков исполнения (Thread).

Concurrency vs Stop The World

+ Параллелизм (Concurrency) - сборщик мусора работает одновременно с самим приложением. Он не ждет, пока heap заполнится
  полностью, он периодически производит "мелкие" сборки, причем эти сборки тоже вызывают событие Stop The World, но по
  времени оно занимает меньше, чем если бы сборщик мусора чистил бы полностью heap.Однако эти минимальные паузы
  достигаются за счет того, что сборщик мусора требует heap больше.
+ Stop The World

Вид сборки:

+ Compacting - GC собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где находятся объекты,
  которые нужно уничтожить
+ Non-compacting - удаляет объекты по месту.
+ Copying - копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были

Виды сборщиков:

· Serial GC

· Parallel GC

· Concurrent Mark Sweep (CMS)

· Garbage-First (G1)

· Z Garbage Collector (ZGC)

К оглавлению [&#8593;](#Оглавление)

## 6 Чем отличаются сборщики мусора?

К оглавлению [&#8593;](#Оглавление)

## 7 Расскажите про утилиты для анализа памяти?

Встроенные в JDK утилиты:

+ jps
+ jmap
+ jstat
+ jconsole
+ visualvm до java 9.

Внешние:

+ VisualVM c java 9
+ YourKit Java Profiler - утилита от NetBeans

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

jps - выводит pid-ы процессов, которые использует VM

jmap - выводит информацию о состоянии памяти виртуальной машины

jmap -heap 14152 или jhsdb jmap --heap --pid 14152

jstat - аналогично jmap

jstack - показывает какие процессы запущены в виртуальной машине (нет инфы о памяти)

К оглавлению [&#8593;](#Оглавление)

## 8 Что такое ссылки?

Ссылки в Java — это указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, в
которой хранится объект. Кроме того, ссылка может быть инициализирована как null — нулевая ссылка, не указывающая ни на
какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом контексте
также может быть использована ссылка this, указывающая на текущий объект, и ссылка super, указывающая на текущий объект
суперкласса.

К оглавлению [&#8593;](#Оглавление)

## 9 Какие типы ссылок Вы знаете?

+ Strong Reference - сильная ссылка - обычная ссылка, которая создаётся при создании объекта. При данном типе ссылок
  объекты удаляются только в том случае, если на них нет сильной ссылки или они находятся в составе объекта на который
  нет ссылки.
+ Soft Reference - безопасная ссылка - удаляется, только если JVM не хватает памяти, т.е. они могут пережить более одной
  сборки мусора. Данный тип ссылок подходит для реализации кэша - такой структуры данных, при которой часть данных
  запоминается, а потом часто переиспользуется.

+ WeakReference - слабая ссылка - удаляется сразу, если на них нет сильных или безопасных ссылок.

К оглавлению [&#8593;](#Оглавление)

## 10 Чем они отличаются?

К оглавлению [&#8593;](#Оглавление)

## 11 Расскажите про String pool и Int pool.

+ String pool

Если строка, созданная при помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый
литерал, уже хранится в специальном месте кучи — в так называемом пуле строк (string pool).

String pool - часть heap, где сохраняются исключительно уникальные значения строковых литералов, а не все строки подряд.
Процесс помещения строк в пул называется интернирование (от англ. interning). Когда мы объявляем переменную типа String
и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там такое же значение. Если пул содержит
необходимое значение, то компилятор просто возвращает ссылку на соответствующий адрес строки без выделения
дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а ссылка на нее возвращена и
присвоена переменной.

+ Int pool

В Java есть пул(pool) целых чисел в промежутке [-128;127]. Т.е. если мы создаем Integer в этом промежутке, то вместо
того, чтобы каждый раз создавать новый объект, JVM берет их из пула.

К оглавлению [&#8593;](#Оглавление)

## 12 Расскажите о методе String.intern().

Метод intern() позволяет у объекта типа String вручную выполнить интернирование строки в пул.

К оглавлению [&#8593;](#Оглавление)

## 13 Расскажите, что такое профайлер.

Профилирование — сбор и анализ характеристик работы программы. Инструмент, используемый для анализа работы, называют
профилировщиком или профайлером

То есть запускаем приложение, вводим в терминале команду (jconsole), тем самым "подключаемся" к приложению, а затем в
реальном времени смотрим, как оно работает, и делаем выводы.

Профайлер – программа, которая осуществляет эти действия. (jmap, jconsole)

К оглавлению [&#8593;](#Оглавление)

## 14 Расскажите, как использовать VisualVM.

К оглавлению [&#8593;](#Оглавление)

## 15 Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

Profiling - это единоразовый снимок состояния в памяти на момент запуска профайлера.

Sampling - это периодическое обновление состояния в памяти, что позволяет наблюдать динамику использования памяти
работающим приложением.

К оглавлению [&#8593;](#Оглавление)

## 16 Расскажите о методе finalize().

В классе Object есть метод finalize(), поэтому он наследуется всеми классами. Этот метод вызывается перед тем, как
объект уничтожится, однако этот метод является устаревшим и не рекомендуется его использовать.

К оглавлению [&#8593;](#Оглавление)

## 17 Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат.

При вызове метода clone(), Java проверяет, был ли у объекта интерфейс Cloneable. Если да — клонирует объект методом
clone(), если нет — выкидывает исключение CloneNotSupportedException.

Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы
маркировать (помечать) некоторые классы. Если разработчик класса считает, что объекты класса можно клонировать, он
помечает класс этим интерфейсом (имплеиентирует интерфейс Cloneable).

Неглубокое копирование Реализация по умолчанию Object.clone()
Метод возвращает точную копию исходного объекта. Он делает это путем полевого присвоения примитивных, изменяемых и
неизменяемых типов. Другими словами, Object.clone() создает новый объект того же типа времени выполнения, что и исходный
объект, и для каждого примитивного, изменяемого и неизменяемого поля выполняет newObj.field = obj.field операция, где
newObj, а также obj являются новым объектом и исходным объектом соответственно.

Это прекрасно работает, если класс содержит только примитивы и неизменяемые поля. Но назначение полей за полем не
приведет к желаемому поведению, если в классе присутствуют какие-либо изменяемые поля, такие как коллекции и массивы,
поскольку память будет разделена между оригиналом и копией. Поскольку объекты, на которые ссылаются, являются общими,
если один из объектов изменяется, изменение отображается в другом. Это не что иное, как __поверхностная__ копия, при
которой копируются ссылки на объекты, а не сами объекты, на которые они ссылаются.

Глубокое копирование При глубоком копировании новые объекты создаются для любых объектов, на которые есть ссылки, а не
для ссылок на копируемые объекты. JDK не предоставляет эквивалент глубокого копирования для Object.clone() метод. Но мы
можем добиться глубокого копирования, изменив реализацию по умолчанию Object.clone() метод и выделить новую память для
изменяемых полей объекта, возвращаемого super.clone(), прежде чем вернуться к вызывающему абоненту. Если в объекте есть
какие-либо ссылки на другие объекты в виде полей, рекомендуется вызвать метод clone() метод на них. Примитивные поля
можно игнорировать, так как их содержимое уже скопировано. Для неизменяемых полей, таких как строка, мы можем позволить
методу скопировать ссылку, и оригинал, и его клон будут совместно использовать один и тот же объект. Теперь любые
изменения, внесенные в клонированный объект, не будут отражаться в исходном объекте и наоборот.

К оглавлению [&#8593;](#Оглавление)

## 18 Расскажите о Stack и Heap.

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap).

1. __Stack__

Стек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод, содержащий
примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти. Из этого можно сделать
вывод, что стек хранит значения примитивных переменных, создаваемых в методах, а также ссылки на объекты в куче, на
которые ссылается метод. Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и
пространство становится доступным для следующего метода. При этом поток выполнения программы возвращается к месту вызова
этого метода с последующим переходом к следующей строке кода.

Особенности:

+ Он заполняется и освобождается по мере вызова и завершения новых методов
+ Переменные в стеке существуют до тех пор, пока выполняется метод, в котором они были созданы
+ Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
+ Доступ к этой области памяти осуществляется быстрее, чем к куче
+ Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

2. __Heap__

Эта область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения. Новые
объекты всегда создаются в куче, а ссылки на них хранятся в стеке. Эти объекты имеют глобальный доступ и могут быть
получены из любого места программы. Эта область памяти разбита на несколько более мелких частей, называемых поколениями:

+ Young Generation — область, где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая
  сборка мусора
+ Old (Tenured) Generation — здесь хранятся долгоживущие объекты.

Особенности:

+ Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError
+ Доступ к ней медленнее, чем к стеку
+ Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик
  мусора
+ В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код

К оглавлению [&#8593;](#Оглавление)