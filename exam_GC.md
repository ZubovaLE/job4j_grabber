# Exam. Garbage Collector

## Оглавление

1. [Чем Java отличается от C++? ](#1-Чем-Java-отличается-от-C++)
2. [Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)
3. [Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)
4. [Опишите процесс работы сборщика мусора.](#4-Опишите-процесс-работы-сборщика-мусора)
5. [Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)
6. [Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)
7. [Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)
8. [Что такое ссылки?](#8-Что-такое-ссылки)
9. [Какие типы ссылок Вы знаете?](#9-Какие-типы-ссылок-Вы-знаете)
10. Чем они отличаются?
11. Расскажите про String pool и Int pool.
12. Расскажите о методе String.intern().
13. Расскажите, что такое профайлер.
14. Расскажите, как использовать VisualVM.
15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)
16. Расскажите о методе finalize().
17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?
18. Расскажите о Stack и Heap.

## 1 Чем Java отличается от C++?

+ Управлением памятью: в Java автоматическая сборка мусора, в то время как в С++ программисту нужно самому позаботиться
  о выделении и освобождении памяти.

К оглавлению [&#8593;](#Оглавление)

## 2 Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), обрабатывающая запросы на
выделение и освобождение оперативной памяти.

К оглавлению [&#8593;](#Оглавление)

## 3 Какой механизм используется в Java для управления памятью?

Распределение памяти в java реализует технология Java HotSpot от Oracle. Она обеспечивает динамическое выделение памяти
для объектов и сборщиков мусора.

Память процесса делится на _non-heap_ (до JDK 8 stack) и _heap_ (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation. Начиная с JDK 8, permanent
generation было удалено, а метаданные класса размещены в собственной памяти. Объем собственной памяти, которую можно
использовать для метаданных класса, по умолчанию не ограничен. Permanent Generation — содержит необходимые для
управления программой метаданные классов, в том числе метаданные о созданных объектах, методах и т.п.

Code Cache — используемая JVM память при включенной JIT-компиляции (в этой области памяти кешируется скомпилированный
платформенно-зависимый код)

Все объекты хранятся в куче (heap). Куча делится на поколения (generation). Есть всего два поколения: молодое (young) и
старое (old). Young generation состоит из eden и survivor space.

Heap - куча (тут и работает GC)

New (Young) Generation - хранит короткоживущие объекты.

Eden Space — сюда аллоцируются среднестатистические объекты. Если нет места запускается малая сборка мусора (minor GC).

Survivor Space — точнее их два, S1 и S2, и они меняются ролями. Хранятся перемещенные из Eden Space объекты, признанные
живыми во время сборки мусора (без разницы малой или полной). Объекты, пережившие несколько сборок мусора, перемещаются
в следующую сборку Tenured Generation.

Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, выполняется полная
сборка мусора (full GC).

Выбор «поколенческой» (generational) модели памяти сделан не спроста. Опытным путем было доказано, что большинство
объектов не живут долго. Это заключение, позволяет сделать young generation небольшим, а в old generation хранить
объекты действительно «живущие» дольше обычного, тем самым эффективно использовать память.

К оглавлению [&#8593;](#Оглавление)

## 4 Опишите процесс работы сборщика мусора.

Сборка мусора происходит, когда заполнена вся область памяти. Раз память делится на два поколения, то бывает два типа
сборки мусора: _minor GC_ и _major GC_. Первый происходит, когда переполняется young generation, второй, когда
переполняется область из old generation.

1. Все объекты рождаются в eden (young generation). Объект рождается. Во время исполнения JVM видит, что стоит оператор
   new. Происходит выделение памяти под объект и возврат ссылки, которая будет ссылаться на занятый участок памяти.
2. GC помечает "живые" объекты (то есть объекты, на которые есть ссылки)
3. Происходит удаление "неживых" объектов
4. Объекты, пережившие сборку мусора, переходят в область survivor (s1)
5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age).
   Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется
   «взрослением» (aging).
6. Объекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением»
   promotion.
7. Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для
   очищения young generation.
8. Когда old generation заполняется производится major GC
9. Этапы 1-7 происходят на протяжении работы программы

К оглавлению [&#8593;](#Оглавление)

## 5 Какие алгоритмы сборщика вы знаете?

К оглавлению [&#8593;](#Оглавление)

## 6 Чем отличаются сборщики мусора?

К оглавлению [&#8593;](#Оглавление)

## 7 Расскажите про утилиты для анализа памяти?

К оглавлению [&#8593;](#Оглавление)

## 8 Что такое ссылки?

К оглавлению [&#8593;](#Оглавление)

## 9 Какие типы ссылок Вы знаете?

+ Strong Reference - сильная ссылка - обычная ссылка, которая создаётся при создании объекта. При данном типе ссылок
  объекты удаляются только в том случае, если на них нет сильной ссылки или они находятся в составе объекта на который
  нет ссылки.
+ Soft Reference - безопасная ссылка - удаляется, только если JVM не хватает памяти, т.е. они могут пережить более одной
  сборки мусора. Данный тип ссылок подходит для реализации кэша - такой структуры данных, при которой часть данных
  запоминается, а потом часто переиспользуется.

+ WeakReference - слабая ссылка - удаляется сразу, если на них нет сильных или безопасных ссылок.

К оглавлению [&#8593;](#Оглавление)

## 10 Чем они отличаются?

## 11 Расскажите про String pool и Int pool.

## 12 Расскажите о методе String.intern().

## 13 Расскажите, что такое профайлер.

## 14 Расскажите, как использовать VisualVM.

## 15 Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

## 16 Расскажите о методе finalize().

## 17 Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

## 18 Расскажите о Stack и Heap.