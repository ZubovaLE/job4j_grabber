# Экзамен. SOLID

## Оглавление

1. [Что такое SOLID?](#1-Что-такое-SOLID)
2. [Для чего используется JavaDoc?](#2-Для-чего-используется-JavaDoc)
3. [Как писать JavaDoc?](#3-Как-писать-JavaDoc)
4. [Что такое Java code convention?](#4-Что-такое-Java-code-convention)
5. [Расскажите про принципы составления Java класса.](#5-Расскажите-про-принципы-составления-Java-класса)
6. [Что такое SRP?](#6-Что-такое-SRP)
7. [Расскажите о нарушениях принципа SRP.](#7-Расскажите-о-нарушениях-принципа-SRP)
8. [Каковы последствия нарушения SRP?](#8-Каковы-последствия-нарушения-SRP)
9. [Что такое OCP?](#9-Что-такое-OCP)
10. [Расскажите о нарушениях принципа OCP.](#10-Расскажите-о-нарушениях-принципа-OCP)
11. [Каковы последствия нарушения OCP?](#11-Каковы-последствия-нарушения-OCP)
12. [Что такое LSP?](#12-Что-такое-LSP)
13. [Расскажите о нарушениях принципа LSP.](#13-Расскажите-о-нарушениях-принципа-LSP)
14. [Каковы последствия нарушения LSP?](#14-Каковы-последствия-нарушения-LSP)
15. [Что такое ISP?](#15-Что-такое-ISP)
16. [Расскажите о нарушениях принципа ISP.](#16-Расскажите-о-нарушениях-принципа-ISP)
17. [Каковы последствия нарушения ISP?](#17-Каковы-последствия-нарушения-ISP)
18. [Что такое DIP?](#19-Что-такое-DIP)
19. [Расскажите о нарушениях принципа DIP.](#19-Расскажите-о-нарушениях-принципа-DIP)
20. [Каковы последствия нарушения DIP?](#20-Каковы-последствия-нарушения-DIP)
21. [Расскажите, что такое автоматизированное тестирование.](#21-Расскажите-что-такое-автоматизированное-тестирование)
22. [Как в Java осуществляется автоматизированное тестирование?](#22-Как-в-Java-осуществляется-автоматизированное-тестирование)
23. [ Что такое JUnit? Как использовать ее для тестирования?](#23-Что-такое-JUnit?-Как-использовать-ее-для-тестирования)
24. [Что такое функциональное тестирование и чем отличается оно от модульного?](#24-Что-такое-функциональное-тестирование-и-чем-отличается-оно-от-модульного)
25. [Расскажите про принцип TDD.](#25-Расскажите-про-принцип-TDD)
26. [Расскажите про принцип BDD.](#26-Расскажите-про-принцип-BDD)
27. [Что такое тестирование черным, белым, серым ящиком?](#27-Что-такое-тестирование-черным-белым-серым-ящиком)

## 1. Что такое SOLID?

SOLID - это аббревиатура, составленная из первых букв в названии принципов объектно-ориентированного дизайна.

S - Single Responsibility Principle (SRP)  
O - Open-Closed Principle (OCP)  
L - Liskov Substitution Principle (LSP)  
I - Interface Segregation Principle (ISP)
D - Dependency Inversion Principle (DIP)

[К оглавлению &#8593;](#Оглавление)

## 2. Для чего используется JavaDoc?

Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java. Комментарий должен находиться
перед документируемым элементом

[К оглавлению &#8593;](#Оглавление)

## 3. Как писать JavaDoc?

Утилита javadoc позволяет вставлять HTML-теги и использовать специальные ярлыки (дескрипторы) документирования.
НТМL-теги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой. Дескрипторы javadoc,
начинающиеся со знака @, называются _автономными_ и должны помещаться с начала строки комментария (лидирующий символ *
игнорируется). Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться
внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и
методов. В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело
комментариев; заканчивается комбинацией символов */. В тело комментариев можно вставлять различные дескрипторы. Каждый
дескриптор, начинающийся с символа '@' должен стоять первым в строке. Несколько дескрипторов одного и того же типа
необходимо группировать вместе. Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого
описания.

[К оглавлению &#8593;](#Оглавление)

## 4. Что такое Java code convention?

Java code conventions - документ Oracle по правилам оформления кода. Соглашения по оформлению кода делают исходный код
программ более удобочитаемым, позволяя инженерам быстрее и тщательнее понимать новый код.

[К оглавлению &#8593;](#Оглавление)

## 5. Расскажите про принципы составления Java класса.

S - Single Responsibility Principle (SRP) - принцип единственной ответственности - класс должен иметь только одну
ответственность  
O - Open-Closed Principle (OCP) - принцип открытости/закрытости - класс должен быть открыт к расширению, но закрыт к
изменению.  
L - Liskov Substitution Principle (LSP) - принцип подстановки Барбары Лисков - объекты в программе можно заменить их
наследниками без изменения свойств программы  
I - Interface Segregation Principle (ISP) - принцип разделения интерфейсов - программные сущности не должны зависеть от
методов, которые они не используют  
D - Dependency Inversion Principle (DIP) - принцип инверсии зависимостей - модули верхнего уровня не должны зависеть от
модулей нижнего уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали
должны зависеть от абстракций.

[К оглавлению &#8593;](#Оглавление)

## 6. Что такое SRP?

Single Responsibility Principle (SRP) - принцип единственной ответственности - класс должен иметь только одну
ответственность. Другая формулировка: класс должен иметь одну и только одну причину для изменения.

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на
обеспечение этой обязанности. Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за
что класс отвечает, а за что — нет.

[К оглавлению &#8593;](#Оглавление)

## 7. Расскажите о нарушениях принципа SRP.

Предположим, есть класс, который обрабатывает заказ, в случае корректности сохраняет его в БД и формирует письмо для
подтверждения заказа, после чего отправляет письмо на почту заказчику.

```java
public class OrderProcessor {

    public void process(Order order) {
        if (order.isValid() && save(order)) {
            sendConfirmationEmail(order);
        }
    }

    private boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }

    private void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}
```

Как видно, класс имеет 3 разные обязанности, которые могут меняться в разное время и по разным причинам:

логика обработки заказа может измениться,   
может измениться способ сохранения заказа в БД (тип базы данных),   
может измениться способ отправки письма подтверждения (вместо email нужно будет отправлять SMS)

А значит, обязанности должны находиться в разных классах или модулях. Решением будет разбиение класса на три отдельных
класса, каждый из которых имеет свою ответственность (обработка заказа, сохранение заказа в БД, отправка письма):

```java
public class MySQLOrderRepository {
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }
}

public class ConfirmationEmailSender {
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}

public class OrderProcessor {
    public void process(Order order) {

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```

[К оглавлению &#8593;](#Оглавление)

## 8. Каковы последствия нарушения SRP?

В примере, описанном в 7 пункте, класс может измениться по трем причинам:

логика обработки заказа может измениться,   
может измениться способ сохранения заказа в БД (тип базы данных),   
может измениться способ отправки письма подтверждения (вместо email нужно будет отправлять SMS)

Тогда придется реализовывать этот функционал, что является следствием некорректного выделения абстракции. Каждая
абстракция должна отвечать только за представления своего функционала.

[К оглавлению &#8593;](#Оглавление)

## 9. Что такое OCP?

O - Open-Closed Principle (OCP) - принцип открытости/закрытости - класс должен быть открыт к расширению, но закрыт к
изменению. То есть сущности могут позволять менять свое поведение без изменения их исходного кода.

Цель OCP — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением
системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в
компонентах уровнем ниже.

[К оглавлению &#8593;](#Оглавление)

## 10. Расскажите о нарушениях принципа OCP.

[К оглавлению &#8593;](#Оглавление)

## 11. Каковы последствия нарушения OCP?

1) Изменение программы может привести к ее некорректной работе. Если программа маленькая, то продебажить ее не трудно,
   но если в ней много кода, то это будет сделать затруднительно, поэтому становится актуальным ее расширение, а не
   изменение.

2) Программы со временем меняются. Меняются требования. Выходят новые версии. Все это делается за счет возможности
   гибкого расширения программы, а в случае нарушения OCP велика вероятность возникновения кучи ошибок вследствие
   изменения кода..

[К оглавлению &#8593;](#Оглавление)

## 12. Что такое LSP?

Liskov Substitution Principle (LSP) - принцип подстановки Барбары Лисков - объекты в программе можно заменить их
наследниками без изменения свойств программы

[К оглавлению &#8593;](#Оглавление)

## 13. Расскажите о нарушениях принципа LSP.

Если класс реализует больше функциональности, чем подкласс, то последний может не поддерживать некоторые функции и тем
самым нарушает данный принцип.

[К оглавлению &#8593;](#Оглавление)

## 14. Каковы последствия нарушения LSP?

Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

[К оглавлению &#8593;](#Оглавление)

## 15. Что такое ISP?

I - Interface Segregation Principle (ISP) - принцип разделения интерфейсов - программные сущности не должны зависеть от
методов, которые они не используют.

[К оглавлению &#8593;](#Оглавление)

## 16. Расскажите о нарушениях принципа ISP.

[К оглавлению &#8593;](#Оглавление)

## 17. Каковы последствия нарушения ISP?

Дублирование кода - мы вынуждены будем переопределять неиспользуемые методы в классах, реализующих "большой" интерфейс.

Кроме того, с точки зрения архитектуры проекта, зависимости, несущие лишний груз ненужных и неиспользуемых особенностей,
могут стать причиной неожиданных проблем.

[К оглавлению &#8593;](#Оглавление)

## 18. Что такое DIP?

D - Dependency Inversion Principle (DIP) - принцип инверсии зависимостей - модули верхнего уровня не должны зависеть от
модулей нижнего уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали
должны зависеть от абстракций.

[К оглавлению &#8593;](#Оглавление)

## 19. Расскажите о нарушениях принципа DIP.

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с
помощью абстракции.

Пример.

Пусть есть модуль, который обрабатывает заказы. Если заказ верно сформирован, он сохраняет его в базу данных и высылает
письмо для подтверждения заказа:

public class OrderProcessor {

    public void process(Order order) {

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

} В данном примере наш OrderProcessor зависит от двух конкретных классов MySQLOrderRepository и ConfirmationEmailSender.
Эти классы далеки от того, чтобы называться абстракциями. И с точки зрения принципа DIP было бы правильнее для начала
создать некоторые абстракции, которые позволят нам оперировать в дальнейшем ими, а не конкретными реализациями. Создадим
два интерфейса MailSender и OrderRepository, которые и станут нашими абстракциями и мплементируем данные интерфейсы в
уже готовых для этого классах:

interface MailSender { void sendConfirmationEmail(Order order); }

interface OrderRepository { boolean save(Order order); }

public class ConfirmationEmailSender implements MailSender { @Override public void sendConfirmationEmail(Order order) {
String name = order.getCustomerName(); String email = order.getCustomerEmail(); // Шлем письмо клиенту } }

public class MySQLOrderRepository implements OrderRepository { @Override public boolean save(Order order) {
MySqlConnection connection = new MySqlConnection("database.url"); // сохраняем заказ в базу данных return true; } }
Теперь наш класс OrderProcessor зависит от абстракций, а не от конкретных реализаций. Внесем в него изменения, внедряя
наши зависимости в конструкторе класса:

public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

} Поведение класса теперь можно без труда менять, внедряя нужную зависимость в момент создания экземпляра
OrderProcessor.

[К оглавлению &#8593;](#Оглавление)

## 20. Каковы последствия нарушения DIP?

Каждое изменение абстрактного интерфейса вызывает изменение его конкретной реализации. Изменение конкретной реализации,
напротив, не всегда сопровождается изменениями и даже обычно не требует изменений в соответствующих интерфейсах. Т.е.
интерфейсы менее изменчивы, чем реализации.

Вместо замены реализации, придется изменять сам класс.

Если в приложении абстракции не отделены от деталей, то изменение логики в низкоуровневых реализациях может неожиданно
привести к поломке высокоуровневых модулей. Тестировать такую систему будет очень сложно. Даже если получится написать
модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать.

В результате получим жесткую, хрупкую, неподвижную систему, которую сложно тестировать.

Жесткость - тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

Хрупкость - когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

Неподвижность - очень сложно повторно использовать код в другом приложении, т.к. модули сильно связаны между собой.

[К оглавлению &#8593;](#Оглавление)

## 21. Расскажите, что такое автоматизированное тестирование.

Автоматизированное тестирования – это процесс написание тестов в виде повторно запускаемого блока кода. Тест – это
проверка заведомо нужного поведения программы.

[К оглавлению &#8593;](#Оглавление)

## 22. Как в Java осуществляется автоматизированное тестирование?

Все тесты базируются на принципе AAA – Arrange Act Assert.

Arrange – указание входных и ожидаемых данных программы.   
Act – выполнение программы путем передачи входных и получение выходных данных.   
Assert – сравнение выходных и ожидаемых данных.

[К оглавлению &#8593;](#Оглавление)

## 23. Что такое JUnit? Как использовать ее для тестирования?

JUnit - библиотека для автоматизированного тестирования.

Юнит-тесты должны быть небольшими. В идеальном случае — одно утверждение (assert) на тест. Так модульнй тест будет
соответствовать SRP, а также быстрее выполняться.

В юнит-тестах стоит использовать шаблон "Arrange, Act and Assert (AAA)", т.е. четко определить:

Arrange - предусловия (инициализация тестовых данных, предварительные установки); Act - действие (вызов тестируемого
метода); Assert - постусловия (что должно быть в результате выполнения действия). Подобное оформление повышает
читаемость кода и облегчает его использование в качестве документации к тестируемой функциональности.

[К оглавлению &#8593;](#Оглавление)

## 24. Что такое функциональное тестирование и чем отличается оно от модульного?

Функциональное тестирование - тестирование в соответствии с функциональными требованиями или бизнес-процессами. Причем
под функциями или процессами здесь понимается то, что доступно и выполняется пользователем.

Модульное тестирование направлено на тестирование методов, классов. На данном уровне достигается максимальная изоляция
для тестирования именно бизнес-логики. Эти тесты чаще пишутся программистами, в курсе мы их используем.

[К оглавлению &#8593;](#Оглавление)

## 25. Расскажите про принцип TDD.

Принцип TDD - это такой подход написания программы, при котором сначала задаётся поведение через тесты, а затем уже
делается реализация. В таком подходе мы фокусируемся на возможности системы, а не на ее реализацию.

[К оглавлению &#8593;](#Оглавление)

## 26. Расскажите про принцип BDD.

BDD - behavior-driven development - разработка на основе поведения - это методология разработки ПО, являющаяся
ответвлением от методологии разработки через тестирование (TDD), при которой особое внимание уделяется описанию
поведения системы/модуля в терминах бизнеса(заказчика).

Основная идея - совмещение в процессе разработки чисто технических интересов и интересов бизнеса. Для общения между
этими группами на естественном языке, понятном неспециалисту, формулируется поведение программного продукта и ожидаемые
результаты.

BDD фокусируется на следующих вопросах:

С чего начинается процесс? Что нужно тестировать, а что нет? Сколько проверок должно быть совершено за один раз? Что
можно назвать проверкой? Как понять, почему тест не прошёл? Исходя из этих вопросов, BDD требует, чтобы имена тестов
были целыми предложениями, которые начинаются с глагола в сослагательном наклонении и следовали бизнес целям. Описание
приемочных тестов должно вестись на гибком языке пользовательской истории, например,

Как [роль того, чьи бизнес-интересы удовлетворяются] я хочу,
чтобы [описание функциональности так, как она должна работать], для того чтобы [описание выгоды].

Критерии приёмки должны быть описаны через сценарий, который реализует пользователь, чтобы достигнуть результата.

Резюме

+ TDD — делать вещи правильно. BDD — делать правильные вещи. Они не взаимозаменяемы.
+ TDD проверяет исключительно модули, а BDD — пользовательские сценарии.
+ TDD используется для разработки через модульное тестирование непосредственно программистами, которые пишут код через
  этот подход. BDD в основном используется для проверки взаимодействия разных компонентов системы, это уровень
  интеграционного тестирования — оно поведенческое и проверяет различные бизнес-кейсы.

TDD — это больше о программировании и тестировании на уровне технической реализации продукта, когда тесты создают сами
разработчики. BDD предполагает описание тестировщиком или аналитиком пользовательских сценариев на естественном языке —
если можно так выразиться, на языке бизнеса.

[К оглавлению &#8593;](#Оглавление)

## 27. Что такое тестирование черным, белым, серым ящиком?

+ тестирование белым ящиком - это тестирование с учетом исходного кода, т.е. мы знаем, как устроена программа и какой
  тест может протестировать ту или иную ветку кода. Пример: модульное тестирование;

+ тестирование черным ящиком - это тестирование без учета исходного кода. Не известно, как программа работает внутри, но
  известны данные, которые она принимает и возвращает. Пример: приемочное тестирование;

+ тестирование серым ящиком - это тестирование находится на стыке белого и черного. Например, известен принцип
  внутренней работы программы и известны данные. Тестирование проводится с учетом и того и другого. Пример:
  регрессионное тестирование.

[К оглавлению &#8593;](#Оглавление)
